--- FILE: ./cmd/main.go ---
package main

import (
	"log"

	"github.com/adexcell/shortener/cmd/app"
)

// @title           Shortener API
// @version         1.0
// @description     URL Shortener Service with Analytics.
// @host            localhost:8080
// @BasePath        /

func main() {
	app, err := app.NewApp()
	if err != nil {
		log.Fatalf("error: %w", err)
	}
	app.Run()
}

--- FILE: ./cmd/app/app.go ---
package app

import (
	"context"
	"net/http"
	"os"
	"os/signal"
	"syscall"

	"github.com/adexcell/shortener/config"
	_ "github.com/adexcell/shortener/docs" // Swagger docs
	"github.com/adexcell/shortener/internal/adapter/postgres"
	"github.com/adexcell/shortener/internal/adapter/redis"
	"github.com/adexcell/shortener/internal/controller"
	"github.com/adexcell/shortener/internal/usecase"
	"github.com/adexcell/shortener/pkg/httpserver"
	"github.com/adexcell/shortener/pkg/logger"
	"github.com/adexcell/shortener/pkg/router"
	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"
)

type App struct {
	cfg     *config.Config
	log     logger.Log
	router  *router.Router
	server  *http.Server
	closers []func() error
}

func NewApp() (*App, error) {
	cfg, err := config.Load()
	if err != nil {
		return nil, err
	}

	log := logger.NewLogger()

	return &App{
		cfg:    cfg,
		log:    log,
		router: router.NewRouter(cfg.Router),
	}, nil
}

func (a *App) Run() {
	a.initDependencies()

	srv := httpserver.New(a.cfg.HTTPServer, a.router)

	// Go routine to start server
	go func() {
		a.log.Info().Str("port", a.cfg.HTTPServer.Port).Msg("Starting server")
		if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			a.log.Error().Err(err).Msg("Server listen failed")
		}
	}()

	// Wait for interrupt signal to gracefully shutdown the server with a timeout of 5 seconds.
	quit := make(chan os.Signal, 1)

	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit
	a.log.Info().Msg("Shutting down server...")

	// The context is used to inform the server it has 5 seconds to finish
	// the request it is currently handling
	ctx, cancel := context.WithTimeout(context.Background(), a.cfg.HTTPServer.ShutdownTimeout)
	defer cancel()

	if err := srv.Shutdown(ctx); err != nil {
		a.log.Fatal().Err(err).Msg("Server forced to shutdown")
	}
	a.shutdown()
}

func (a *App) initDependencies() {
	storage, err := postgres.NewShortenerPostgres(a.cfg.Postgres)
	if err != nil {
		a.log.Fatal().Err(err).Msg("Failed to init Postgres")
	}
	a.addCloser(storage.Close)

	redis := redis.NewShortenerRedis(a.cfg.Redis)
	a.addCloser(redis.Close)

	shortenerUsecase := usecase.NewShortenerUsecase(storage, redis, a.log, a.cfg.Redis.TTL)
	a.addCloser(shortenerUsecase.Close)
	shortenHandler := controller.NewShortenHandler(shortenerUsecase, a.log)

	a.router.Static("/static", "./static")
	a.router.StaticFile("/", "./static/index.html")

	// Swagger
	a.router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

	a.log.Info().Msg("register shorten handler")
	shortenHandler.Register(a.router)
}

func (a *App) addCloser(closer func() error) {
	a.closers = append(a.closers, closer)
}

func (a *App) shutdown() {
	for i := len(a.closers) - 1; i >= 0; i-- {
		if err := a.closers[i](); err != nil {
			a.log.Error().Err(err).Msg("failed to close resource")
		}
	}
}

--- FILE: ./go.mod ---
module github.com/adexcell/shortener

go 1.25.5

require (
	github.com/go-playground/validator/v10 v10.30.1
	github.com/lib/pq v1.10.9
	github.com/stretchr/testify v1.11.1
	github.com/swaggo/files v1.0.1
	github.com/swaggo/gin-swagger v1.6.1
	github.com/swaggo/swag v1.16.6
	github.com/wb-go/wbf v0.0.12
)

require (
	github.com/KyleBanks/depth v1.2.1 // indirect
	github.com/PuerkitoBio/purell v1.2.1 // indirect
	github.com/PuerkitoBio/urlesc v0.0.0-20170810143723-de5bf2ad4578 // indirect
	github.com/bytedance/sonic v1.9.1 // indirect
	github.com/cespare/xxhash/v2 v2.1.2 // indirect
	github.com/chenzhuoyu/base64x v0.0.0-20221115062448-fe3a3abad311 // indirect
	github.com/davecgh/go-spew v1.1.2-0.20180830191138-d8f796af33cc // indirect
	github.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f // indirect
	github.com/fsnotify/fsnotify v1.7.0 // indirect
	github.com/gabriel-vasile/mimetype v1.4.12 // indirect
	github.com/gin-contrib/sse v0.1.0 // indirect
	github.com/gin-gonic/gin v1.9.1 // indirect
	github.com/go-openapi/jsonpointer v0.22.4 // indirect
	github.com/go-openapi/jsonreference v0.21.4 // indirect
	github.com/go-openapi/spec v0.22.3 // indirect
	github.com/go-openapi/swag v0.25.4 // indirect
	github.com/go-openapi/swag/conv v0.25.4 // indirect
	github.com/go-openapi/swag/jsonname v0.25.4 // indirect
	github.com/go-openapi/swag/jsonutils v0.25.4 // indirect
	github.com/go-openapi/swag/loading v0.25.4 // indirect
	github.com/go-openapi/swag/stringutils v0.25.4 // indirect
	github.com/go-openapi/swag/typeutils v0.25.4 // indirect
	github.com/go-openapi/swag/yamlutils v0.25.4 // indirect
	github.com/go-playground/locales v0.14.1 // indirect
	github.com/go-playground/universal-translator v0.18.1 // indirect
	github.com/go-redis/redis/v8 v8.11.5 // indirect
	github.com/goccy/go-json v0.10.2 // indirect
	github.com/google/uuid v1.4.0 // indirect
	github.com/hashicorp/hcl v1.0.0 // indirect
	github.com/joho/godotenv v1.5.1 // indirect
	github.com/josharian/intern v1.0.0 // indirect
	github.com/json-iterator/go v1.1.12 // indirect
	github.com/klauspost/cpuid/v2 v2.2.4 // indirect
	github.com/leodido/go-urn v1.4.0 // indirect
	github.com/magiconair/properties v1.8.7 // indirect
	github.com/mailru/easyjson v0.9.1 // indirect
	github.com/mattn/go-colorable v0.1.13 // indirect
	github.com/mattn/go-isatty v0.0.19 // indirect
	github.com/mitchellh/mapstructure v1.5.0 // indirect
	github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect
	github.com/modern-go/reflect2 v1.0.2 // indirect
	github.com/pelletier/go-toml/v2 v2.1.0 // indirect
	github.com/pmezard/go-difflib v1.0.1-0.20181226105442-5d4384ee4fb2 // indirect
	github.com/rs/zerolog v1.30.0 // indirect
	github.com/sagikazarmark/locafero v0.4.0 // indirect
	github.com/sagikazarmark/slog-shim v0.1.0 // indirect
	github.com/sourcegraph/conc v0.3.0 // indirect
	github.com/spf13/afero v1.11.0 // indirect
	github.com/spf13/cast v1.6.0 // indirect
	github.com/spf13/pflag v1.0.5 // indirect
	github.com/spf13/viper v1.18.2 // indirect
	github.com/stretchr/objx v0.5.2 // indirect
	github.com/subosito/gotenv v1.6.0 // indirect
	github.com/twitchyliquid64/golang-asm v0.15.1 // indirect
	github.com/ugorji/go/codec v1.2.11 // indirect
	go.uber.org/atomic v1.9.0 // indirect
	go.uber.org/multierr v1.9.0 // indirect
	go.yaml.in/yaml/v3 v3.0.4 // indirect
	golang.org/x/arch v0.3.0 // indirect
	golang.org/x/crypto v0.46.0 // indirect
	golang.org/x/exp v0.0.0-20230905200255-921286631fa9 // indirect
	golang.org/x/mod v0.31.0 // indirect
	golang.org/x/net v0.48.0 // indirect
	golang.org/x/sync v0.19.0 // indirect
	golang.org/x/sys v0.39.0 // indirect
	golang.org/x/text v0.32.0 // indirect
	golang.org/x/tools v0.40.0 // indirect
	google.golang.org/protobuf v1.33.0 // indirect
	gopkg.in/ini.v1 v1.67.0 // indirect
	gopkg.in/yaml.v2 v2.4.0 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)

--- FILE: ./docs/swagger.yaml ---
basePath: /
definitions:
  controller.shortenRequest:
    properties:
      alias:
        description: кастомное имя сокращенной ссылки
        type: string
      url:
        description: URL - полная ссылка
        type: string
    required:
    - url
    type: object
  controller.statsControllerDTO:
    properties:
      by_browser:
        additionalProperties:
          type: integer
        type: object
      by_date:
        additionalProperties:
          type: integer
        type: object
      clicked_at:
        type: string
      id:
        type: string
      ip:
        type: string
      short_code:
        type: string
      total_clicks:
        type: integer
      user_agent:
        type: string
    type: object
host: localhost:8080
info:
  contact: {}
  description: URL Shortener Service with Analytics.
  title: Shortener API
  version: "1.0"
paths:
  /analytics/{short_url}:
    get:
      description: Get click statistics for a short URL
      parameters:
      - description: Short URL alias
        in: path
        name: short_url
        required: true
        type: string
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            $ref: '#/definitions/controller.statsControllerDTO'
        "500":
          description: Internal Server Error
          schema:
            additionalProperties:
              type: string
            type: object
      summary: Get URL Analytics
      tags:
      - analytics
  /s/{short_url}:
    get:
      description: Redirect user to the original long URL based on the short alias
      parameters:
      - description: Short URL alias
        in: path
        name: short_url
        required: true
        type: string
      produces:
      - text/html
      responses:
        "302":
          description: Redirect to original URL
          schema:
            type: string
        "404":
          description: Not Found
          schema:
            additionalProperties:
              type: string
            type: object
      summary: Redirect to original URL
      tags:
      - shortener
  /shorten:
    post:
      consumes:
      - application/json
      description: Generate a short alias for a given long URL
      parameters:
      - description: URL to shorten
        in: body
        name: input
        required: true
        schema:
          $ref: '#/definitions/controller.shortenRequest'
      produces:
      - application/json
      responses:
        "200":
          description: OK
          schema:
            additionalProperties:
              type: string
            type: object
        "400":
          description: Bad Request
          schema:
            additionalProperties:
              type: string
            type: object
        "422":
          description: Unprocessable Entity
          schema:
            additionalProperties:
              type: string
            type: object
        "500":
          description: Internal Server Error
          schema:
            additionalProperties:
              type: string
            type: object
      summary: Shorten URL
      tags:
      - shortener
swagger: "2.0"

--- FILE: ./docs/docs.go ---
// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/analytics/{short_url}": {
            "get": {
                "description": "Get click statistics for a short URL",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "analytics"
                ],
                "summary": "Get URL Analytics",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Short URL alias",
                        "name": "short_url",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/controller.statsControllerDTO"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/s/{short_url}": {
            "get": {
                "description": "Redirect user to the original long URL based on the short alias",
                "produces": [
                    "text/html"
                ],
                "tags": [
                    "shortener"
                ],
                "summary": "Redirect to original URL",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Short URL alias",
                        "name": "short_url",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "302": {
                        "description": "Redirect to original URL",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/shorten": {
            "post": {
                "description": "Generate a short alias for a given long URL",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "shortener"
                ],
                "summary": "Shorten URL",
                "parameters": [
                    {
                        "description": "URL to shorten",
                        "name": "input",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/controller.shortenRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "422": {
                        "description": "Unprocessable Entity",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "controller.shortenRequest": {
            "type": "object",
            "required": [
                "url"
            ],
            "properties": {
                "alias": {
                    "description": "кастомное имя сокращенной ссылки",
                    "type": "string"
                },
                "url": {
                    "description": "URL - полная ссылка",
                    "type": "string"
                }
            }
        },
        "controller.statsControllerDTO": {
            "type": "object",
            "properties": {
                "by_browser": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "integer"
                    }
                },
                "by_date": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "integer"
                    }
                },
                "clicked_at": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "ip": {
                    "type": "string"
                },
                "short_code": {
                    "type": "string"
                },
                "total_clicks": {
                    "type": "integer"
                },
                "user_agent": {
                    "type": "string"
                }
            }
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &swag.Spec{
	Version:          "1.0",
	Host:             "localhost:8080",
	BasePath:         "/",
	Schemes:          []string{},
	Title:            "Shortener API",
	Description:      "URL Shortener Service with Analytics.",
	InfoInstanceName: "swagger",
	SwaggerTemplate:  docTemplate,
	LeftDelim:        "{{",
	RightDelim:       "}}",
}

func init() {
	swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}

--- FILE: ./internal/domain/stats.go ---
package domain

import (
	"fmt"
	"time"

	"github.com/adexcell/shortener/pkg/utils/uuid"
)

type Stats struct {
	ID          string
	ShortCode   string
	IP          string `validate:"required,ip"`
	UserAgent   string
	TotalClicks int
	ByDate      map[string]int
	ByBrowser   map[string]int
	ClickedAt   time.Time
}

func NewStats(shortCode, ip, userAgent string) (Stats, error) {
	s := Stats{
		ID:        uuid.New(),
		ShortCode: shortCode,
		IP:        ip,
		UserAgent: userAgent,
	}

	if err := s.Validate(); err != nil {
		return Stats{}, fmt.Errorf("u.Validate: %w", err)
	}

	return s, nil
}

func (s Stats) Validate() error {
	err := validate.Struct(s)
	if err != nil {
		return fmt.Errorf("validate.Struct Stats: %w", err)
	}

	return nil
}

--- FILE: ./internal/domain/shortener.go ---
// Package domain содержит основные бизнес модели и интерфейсы.
package domain

import (
	"context"
	"fmt"
	"time"

	"github.com/adexcell/shortener/pkg/utils/uuid"
	"github.com/go-playground/validator/v10"
)

type Shortener struct {
	ID        string
	ShortCode string
	LongURL   string `validate:"required,url"`
	CreatedAt time.Time
}

var validate = validator.New(validator.WithRequiredStructEnabled())

func NewShortener(shortCode, longURL string) (Shortener, error) {
	s := Shortener{
		ID:        uuid.New(),
		ShortCode: shortCode,
		LongURL:   longURL,
	}

	if err := s.Validate(); err != nil {
		return Shortener{}, fmt.Errorf("u.Validate: %w", err)
	}

	return s, nil
}

func (s Shortener) Validate() error {
	err := validate.Struct(s)
	if err != nil {
		return fmt.Errorf("validate.Struct Shortener: %w", err)
	}

	return nil
}

type ShortenerPostgres interface {
	Save(ctx context.Context, shortCode, longURL string) error
	GetLongURL(ctx context.Context, shortCode string) (string, error)
	SaveClick(ctx context.Context, shortCode, ip, userAgent string) error
	GetDetailedStats(ctx context.Context, shortCode string) (Stats, error)
	Close() error
}

type ShortenerRedis interface {
	SetWithExpiration(ctx context.Context, key string, value any, expiration time.Duration) error
	Get(ctx context.Context, key string) (string, error)
	Close() error
}

type ShortenerUsecase interface {
	Shorten(ctx context.Context, longURL, alias string) (string, error)
	GetOriginal(ctx context.Context, shortCode, ip, userAgent string) (string, error)
	GetStats(ctx context.Context, shortCode string) (Stats, error)
	Close() error
}

--- FILE: ./internal/domain/errors.go ---
package domain

import "errors"

var (
	ErrAlreadyExists = errors.New("this alias is already taken")
)

--- FILE: ./internal/adapter/redis/shortener.go ---
package redis

import (
	"context"
	"time"

	"github.com/adexcell/shortener/internal/domain"
	"github.com/adexcell/shortener/pkg/redis"
)

type ShortenerRedis struct {
	redis *redis.RDB
}

func NewShortenerRedis(cfg redis.Config) domain.ShortenerRedis {
	redis := redis.NewRedis(cfg)
	return &ShortenerRedis{redis: redis}
}

func (r *ShortenerRedis) SetWithExpiration(
	ctx context.Context,
	key string,
	value any,
	expiration time.Duration,
) error {
	return r.redis.SetWithExpiration(ctx, key, value, expiration)
}

func (r *ShortenerRedis) Get(ctx context.Context, key string) (string, error) {
	return r.redis.Get(ctx, key)
}

func (r *ShortenerRedis) Close() error {
	return r.redis.Close()
}

--- FILE: ./internal/adapter/postgres/stats_dto.go ---
package postgres

import (
	"time"

	"github.com/adexcell/shortener/internal/domain"
)

type statsPostgresDTO struct {
	ID          string `db:"id"`
	ShortCode   string `db:"short_code"`
	IP          string `db:"ip"`
	UserAgent   string `db:"user_agent"`
	TotalClicks int
	ByDate      map[string]int
	ByBrowser   map[string]int
	ClickedAt   time.Time `db:"clicked_at"`
}

func statsToPostgresDTO(shortCode, ip, userAgent string) (*statsPostgresDTO, error) {
	s, err := domain.NewStats(shortCode, ip, userAgent)
	if err != nil {
		return &statsPostgresDTO{}, err
	}

	res := &statsPostgresDTO{
		ID:          s.ID,
		ShortCode:   s.ShortCode,
		IP:          s.IP,
		UserAgent:   s.UserAgent,
		TotalClicks: s.TotalClicks,
		ByDate:      s.ByDate,
		ByBrowser:   s.ByBrowser,
		ClickedAt:   s.ClickedAt,
	}
	return res, nil
}

func statsToDomain(dto statsPostgresDTO) domain.Stats {
	return domain.Stats{
		ID:          dto.ID,
		ShortCode:   dto.ShortCode,
		IP:          dto.IP,
		UserAgent:   dto.UserAgent,
		TotalClicks: dto.TotalClicks,
		ByDate:      dto.ByDate,
		ByBrowser:   dto.ByBrowser,
		ClickedAt:   dto.ClickedAt,
	}
}

--- FILE: ./internal/adapter/postgres/shortener.go ---
package postgres

import (
	"context"
	"encoding/json"

	"github.com/adexcell/shortener/internal/domain"
	"github.com/adexcell/shortener/pkg/postgres"
)

type ShortenerPostgres struct {
	db *postgres.DB
}

func NewShortenerPostgres(cfg postgres.Config) (domain.ShortenerPostgres, error) {
	db, err := postgres.NewPostgres(cfg)
	return &ShortenerPostgres{db: db}, err
}

func (p *ShortenerPostgres) Save(ctx context.Context, shortCode, longURL string) error {
	dto, err := shortenerToPostgresDTO(shortCode, longURL)
	if err != nil {
		return err
	}

	query := `
	INSERT INTO urls (id, short_code, long_url)
	VALUES ($1, $2, $3)`

	_, err = p.db.ExecContext(ctx, query, dto.ID, dto.ShortCode, dto.LongURL)
	return err
}

func (p *ShortenerPostgres) GetLongURL(ctx context.Context, shortCode string) (string, error) {
	var longURL string
	query := `
	SELECT long_url FROM urls
	WHERE short_code = $1`
	err := p.db.QueryRowContext(ctx, query, shortCode).Scan(&longURL)
	return longURL, err
}

func (p *ShortenerPostgres) SaveClick(ctx context.Context, shortCode, ip, userAgent string) error {
	dto, err := statsToPostgresDTO(shortCode, ip, userAgent)
	if err != nil {
		return err
	}

	query := `
	INSERT INTO analytics (id, short_code, ip, user_agent)
	VALUES ($1, $2, $3, $4)`

	_, err = p.db.ExecContext(
		ctx,
		query,
		dto.ID,
		dto.ShortCode,
		dto.IP,
		dto.UserAgent,
	)
	return err
}

func (p *ShortenerPostgres) GetDetailedStats(ctx context.Context, shortCode string) (domain.Stats, error) {
	var dto statsPostgresDTO
	dto.ByDate = make(map[string]int)
	dto.ByBrowser = make(map[string]int)

	// total clicks
	query := `
	WITH raw_stats AS (
		-- Шаг 1: Берем все клики по коду один раз
		SELECT 
			clicked_at, 
			user_agent,
			COUNT(*) OVER() as total_count -- считает общее кол-во строк во всем результате
		FROM analytics
		WHERE short_code = $1
	),
	by_date AS (
		-- Шаг 2: Группируем по датам
		SELECT TO_CHAR(clicked_at, 'YYYY-MM-DD') as d, COUNT(*) as c
		FROM raw_stats
		GROUP BY d
		ORDER BY d DESC
		LIMIT 7
	),
	by_browser AS (
		-- Шаг 3: Группируем по браузерам
		SELECT user_agent as b, COUNT(*) as c
		FROM raw_stats
		GROUP BY b
	)
	-- Собираем всё в одну строку
	SELECT 
		COALESCE((SELECT total_count FROM raw_stats LIMIT 1), 0) as total,
		COALESCE((SELECT jsonb_object_agg(d, c) FROM by_date), {}) as dates,
		COALESCE((SELECT jsonb_object_agg(b, c) FROM by_browser), {}) as browsers;`

	var dates, browsers []byte
	err := p.db.QueryRowContext(ctx, query, shortCode).Scan(&dto.TotalClicks, &dates, &browsers)
	if err != nil {
		return domain.Stats{}, err
	}

	if err := json.Unmarshal(dates, &dto.ByDate); err != nil {
		return domain.Stats{}, err
	}
	if err := json.Unmarshal(browsers, &dto.ByBrowser); err != nil {
		return domain.Stats{}, err
	}

	res := statsToDomain(dto)

	return res, nil
}

func (p *ShortenerPostgres) Close() error {
	return p.db.Master.Close()
}

--- FILE: ./internal/adapter/postgres/shortener_dto.go ---
package postgres

import (
	"time"

	"github.com/adexcell/shortener/internal/domain"
)

type shortenerPostgresDTO struct {
	ID        string    `db:"id"`
	ShortCode string    `db:"short_code"`
	LongURL   string    `db:"long_url"`
	CreatedAt time.Time `db:"created_at"`
}

func shortenerToPostgresDTO(shortCode, longURL string) (*shortenerPostgresDTO, error) {
	s, err := domain.NewShortener(shortCode, longURL)
	if err != nil {
		return &shortenerPostgresDTO{}, err
	}

	res := &shortenerPostgresDTO{
		ID:        s.ID,
		ShortCode: s.ShortCode,
		LongURL:   s.LongURL,
	}
	return res, nil
}

func shortenerToDomain(dto shortenerPostgresDTO) *domain.Shortener {
	return &domain.Shortener{
		ID:        dto.ID,
		ShortCode: dto.ShortCode,
		LongURL:   dto.LongURL,
		CreatedAt: dto.CreatedAt,
	}
}



--- FILE: ./internal/usecase/shortener.go ---
// Package usecase содержит основную бизнес-логику.
package usecase

import (
	"context"
	"crypto/rand"
	"encoding/base64"
	"fmt"
	"sync"
	"time"

	"github.com/adexcell/shortener/internal/domain"
	"github.com/adexcell/shortener/pkg/logger"
	"github.com/adexcell/shortener/pkg/postgres"
)

type ShortenerUsecase struct {
	log      logger.Log
	postgres domain.ShortenerPostgres
	redis    domain.ShortenerRedis
	ttl      time.Duration
	statsCh  chan domain.Stats
	wg       sync.WaitGroup
	mu       sync.RWMutex
	closed   bool
}

func NewShortenerUsecase(
	p domain.ShortenerPostgres,
	r domain.ShortenerRedis,
	l logger.Log,
	t time.Duration,
) domain.ShortenerUsecase {
	u := &ShortenerUsecase{
		log:      l,
		postgres: p,
		redis:    r,
		ttl:      t,
		statsCh:  make(chan domain.Stats, 1000),
	}

	u.wg.Add(1)
	go u.runAnalyticsWorker()

	return u
}

// Shorten генерирует код и сохраняет в БД
func (u *ShortenerUsecase) Shorten(ctx context.Context, shortCode, longURL string) (string, error) {
	if shortCode == "" {
		b := make([]byte, 4)
		rand.Read(b)
		shortCode = base64.URLEncoding.EncodeToString(b)[:6]
	}

	err := u.postgres.Save(ctx, shortCode, longURL)
	if err != nil {
		return "", postgres.PostgresErr(err)
	}

	if err := u.redis.SetWithExpiration(ctx, shortCode, longURL, u.ttl); err != nil {
		u.log.Error().Err(err).Str("code", shortCode).Msg("failed to save click analytics in redis")
	}

	return shortCode, nil
}

// GetOriginal ищет полную ссылку по коду
func (u *ShortenerUsecase) GetOriginal(ctx context.Context, shortCode, ip, userAgent string) (string, error) {
	longURL, err := u.redis.Get(ctx, shortCode)
	if err != nil {
		longURL, err = u.postgres.GetLongURL(ctx, shortCode)
		if err != nil {
			return "", fmt.Errorf("failed to get long url from db: %w", err)
		}

		if err := u.redis.SetWithExpiration(ctx, shortCode, longURL, u.ttl); err != nil {
			u.log.Error().Err(err).Str("code", shortCode).Msg("failed to save click analytics in redis")
		}
	}

	stats := domain.Stats{
		ShortCode: shortCode,
		IP:        ip,
		UserAgent: userAgent,
	}

	u.mu.RLock()
	defer u.mu.RUnlock()
	if u.closed {
		return longURL, nil
	}
	select {
	case u.statsCh <- stats:
		// успешно отправили
	default:
		u.log.Warn().Str("code", shortCode).Msg("analytics channel full, dropping stat")
	}
	

	return longURL, nil
}

func (u *ShortenerUsecase) GetStats(ctx context.Context, shortCode string) (domain.Stats, error) {
	return u.postgres.GetDetailedStats(ctx, shortCode)
}

func (u *ShortenerUsecase) runAnalyticsWorker() {
	defer u.wg.Done()

	u.log.Info().Msg("analytics worker started")

	for stats := range u.statsCh {
		err := u.postgres.SaveClick(context.Background(), stats.ShortCode, stats.IP, stats.UserAgent)
		if err != nil {
			u.log.Error().Err(err).Str("code", stats.ShortCode).Msg("failed to save click analytics in postgres")
		}
	}
}

func (u *ShortenerUsecase) Close() error {
	u.mu.Lock()
	u.closed = true
	u.mu.Unlock()

	close(u.statsCh)

	u.wg.Wait()
	return nil
}

--- FILE: ./internal/usecase/shortener_test.go ---
package usecase_test

import (
	"context"
	"errors"
	"testing"
	"time"

	"github.com/adexcell/shortener/internal/domain"
	"github.com/adexcell/shortener/internal/usecase"
	"github.com/adexcell/shortener/pkg/logger"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

// --- Mocks ---

const (
	TTL = 24 * time.Hour
)

type MockPostgres struct {
	mock.Mock
}

func (m *MockPostgres) Save(ctx context.Context, shortCode, longURL string) error {
	args := m.Called(ctx, shortCode, longURL)
	return args.Error(0)
}

func (m *MockPostgres) GetLongURL(ctx context.Context, shortCode string) (string, error) {
	args := m.Called(ctx, shortCode)
	return args.String(0), args.Error(1)
}

func (m *MockPostgres) SaveClick(ctx context.Context, shortCode, ip, userAgent string) error {
	args := m.Called(ctx, shortCode, ip, userAgent)
	return args.Error(0)
}

func (m *MockPostgres) GetDetailedStats(ctx context.Context, shortCode string) (domain.Stats, error) {
	args := m.Called(ctx, shortCode)
	return args.Get(0).(domain.Stats), args.Error(1)
}

func (m *MockPostgres) Close() error {
	return nil
}

type MockRedis struct {
	mock.Mock
}

func (m *MockRedis) SetWithExpiration(ctx context.Context, key string, value any, expiration time.Duration) error {
	args := m.Called(ctx, key, value, expiration)
	return args.Error(0)
}

func (m *MockRedis) Get(ctx context.Context, key string) (string, error) {
	args := m.Called(ctx, key)
	return args.String(0), args.Error(1)
}

func (m *MockRedis) Close() error {
	return nil
}

// --- Tests ---

func TestShortenerUsecase_Shorten(t *testing.T) {
	ctx := context.Background()
	mockPg := new(MockPostgres)
	mockRedis := new(MockRedis)
	log := logger.NewLogger()

	uc := usecase.NewShortenerUsecase(mockPg, mockRedis, log, TTL)
	longURL := "https://example.com"

	t.Run("success", func(t *testing.T) {
		// Expectation: Save to postgres, then save to redis
		mockPg.On("Save", ctx, mock.AnythingOfType("string"), longURL).Return(nil).Once()
		mockRedis.On("SetWithExpiration", ctx, mock.AnythingOfType("string"), longURL, 24*time.Hour).Return(nil).Once()

		code, err := uc.Shorten(ctx, "", longURL)

		assert.NoError(t, err)
		assert.NotEmpty(t, code)
		assert.Len(t, code, 6)
		mockPg.AssertExpectations(t)
		mockRedis.AssertExpectations(t)
	})

	t.Run("postgres error", func(t *testing.T) {
		mockPg.On("Save", ctx, mock.AnythingOfType("string"), longURL).Return(errors.New("db error")).Once()

		code, err := uc.Shorten(ctx, "", longURL)

		assert.Error(t, err)
		assert.Empty(t, code)
		mockPg.AssertExpectations(t)
	})
}

func TestShortenerUsecase_GetOriginal(t *testing.T) {
	mockPg := new(MockPostgres)
	mockRedis := new(MockRedis)
	log := logger.NewLogger()
	ctx := context.Background()

	uc := usecase.NewShortenerUsecase(mockPg, mockRedis, log, TTL)
	shortCode := "abcdef"
	longURL := "https://example.com"
	ip := "127.0.0.1"
	ua := "Go-Test"

	t.Run("redis hit", func(t *testing.T) {
		mockRedis.On("Get", ctx, shortCode).Return(longURL, nil).Once()
		// SaveClick is called in a goroutine, so we might not be able to assert it reliably without sync.
		// However, the mock might catch it if we add a wait or sleep, but for unit test speed we often ignore async calls or just mock them loosely.
		// For this test, we accept if it's called or not, BUT mocks are strict.
		// If the code calls mock, we MUST expect it or use .Maybe()
		// Since it's async context.Background(), the mocking might happen after test finishes.
		// We'll define it as .Maybe() or use a separate mock instance if we wanted strict async testing.
		// Let's use .Maybe() and .Return(nil) to prevent panic if it is called.
		mockPg.On("SaveClick", mock.Anything, shortCode, ip, ua).Return(nil).Maybe()

		url, err := uc.GetOriginal(ctx, shortCode, ip, ua)

		assert.NoError(t, err)
		assert.Equal(t, longURL, url)
		mockRedis.AssertExpectations(t)
	})

	t.Run("redis miss, postgres hit", func(t *testing.T) {
		mockRedis.On("Get", ctx, shortCode).Return("", errors.New("not found")).Once()
		mockPg.On("GetLongURL", ctx, shortCode).Return(longURL, nil).Once()
		mockRedis.On("SetWithExpiration", ctx, shortCode, longURL, 24*time.Hour).Return(nil).Once()
		mockPg.On("SaveClick", mock.Anything, shortCode, ip, ua).Return(nil).Maybe()

		url, err := uc.GetOriginal(ctx, shortCode, ip, ua)

		assert.NoError(t, err)
		assert.Equal(t, longURL, url)
		mockPg.AssertExpectations(t)
		mockRedis.AssertExpectations(t)
	})

	t.Run("not found everywhere", func(t *testing.T) {
		mockRedis.On("Get", ctx, shortCode).Return("", errors.New("not found")).Once()
		mockPg.On("GetLongURL", ctx, shortCode).Return("", errors.New("not found")).Once()

		url, err := uc.GetOriginal(ctx, shortCode, ip, ua)

		assert.NoError(t, err) // The usecase returns empty string and nil error on not found (based on code reading)
		assert.Empty(t, url)
		mockPg.AssertExpectations(t)
		mockRedis.AssertExpectations(t)
	})
}

--- FILE: ./internal/controller/stats_dto.go ---
package controller

import (
	"time"

	"github.com/adexcell/shortener/internal/domain"
)

type statsControllerDTO struct {
	ID          string         `json:"id"`
	ShortCode   string         `json:"short_code"`
	IP          string         `json:"ip"`
	UserAgent   string         `json:"user_agent"`
	TotalClicks int            `json:"total_clicks"`
	ByDate      map[string]int `json:"by_date"`
	ByBrowser   map[string]int `json:"by_browser"`
	ClickedAt   time.Time      `json:"clicked_at"`
}

func statsToControllerDTO(shortCode, ip, userAgent string) (*statsControllerDTO, error) {
	s, err := domain.NewStats(shortCode, ip, userAgent)
	if err != nil {
		return &statsControllerDTO{}, err
	}

	res := &statsControllerDTO{
		ID:          s.ID,
		ShortCode:   s.ShortCode,
		IP:          s.IP,
		UserAgent:   s.UserAgent,
		TotalClicks: s.TotalClicks,
		ByDate:      s.ByDate,
		ByBrowser:   s.ByBrowser,
		ClickedAt:   s.ClickedAt,
	}
	return res, nil
}

func statsToResponse(s domain.Stats) statsControllerDTO {
	return statsControllerDTO{
		ID:          s.ID,
		ShortCode:   s.ShortCode,
		IP:          s.IP,
		UserAgent:   s.UserAgent,
		TotalClicks: s.TotalClicks,
		ByDate:      s.ByDate,
		ByBrowser:   s.ByBrowser,
		ClickedAt:   s.ClickedAt,
	}
}

--- FILE: ./internal/controller/shortener.go ---
// Package controller содержит API http_v1.
package controller

import (
	"errors"
	"net/http"

	"github.com/adexcell/shortener/internal/domain"
	"github.com/adexcell/shortener/pkg/logger"
	"github.com/adexcell/shortener/pkg/router"
)

const (
	postShortURL  = "/shorten"
	conversionURL = "/s/:short_url"
	analyticsURL  = "/analytics/:short_url"
)

type handler struct {
	usecase domain.ShortenerUsecase
	log     logger.Log
}

func NewShortenHandler(u domain.ShortenerUsecase, l logger.Log) router.Handler {
	return &handler{usecase: u, log: l}
}

func (h *handler) Register(router *router.Router) {
	router.POST(postShortURL, h.PostShortURL)
	router.GET(conversionURL, h.ConversionURL)
	router.GET(analyticsURL, h.GetAnalytics)
}

type shortenRequest struct {
	// URL - полная ссылка
	URL string `json:"url" binding:"required"`
	// кастомное имя сокращенной ссылки
	Alias string `json:"alias"`
}

// PostShortURL godoc
// @Summary      Shorten URL
// @Description  Generate a short alias for a given long URL
// @Tags         shortener
// @Accept       json
// @Produce      json
// @Param        input body shortenRequest true "URL to shorten"
// @Success      200  {object}  map[string]string
// @Failure      400  {object}  map[string]string
// @Failure      422  {object}  map[string]string
// @Failure      500  {object}  map[string]string
// @Router       /shorten [post]
func (h *handler) PostShortURL(c *router.Context) {
	var req shortenRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, router.H{"error": "invalid request"})
		return
	}

	dto, err := shortenerToControllerDTO(req.Alias, req.URL)
	if err != nil {
		c.JSON(http.StatusUnprocessableEntity, router.H{"error": err.Error()})
		return
	}

	code, err := h.usecase.Shorten(c.Request.Context(), dto.ShortCode, dto.LongURL)
	if err != nil {
		if errors.Is(err, domain.ErrAlreadyExists) {
			c.JSON(http.StatusConflict, router.H{"error": domain.ErrAlreadyExists})
			return
		}
		h.log.Error().Err(err).Msg("failed to shorten url")
		c.JSON(http.StatusInternalServerError, router.H{"error": "db error"})
		return
	}

	c.JSON(http.StatusOK, router.H{"short_url": code})
}

// ConversionURL godoc
// @Summary      Redirect to original URL
// @Description  Redirect user to the original long URL based on the short alias
// @Tags         shortener
// @Produce      html
// @Param        short_url path string true "Short URL alias"
// @Success      302  {string}  string "Redirect to original URL"
// @Failure      404  {object}  map[string]string
// @Router       /s/{short_url} [get]
func (h *handler) ConversionURL(c *router.Context) {
	code := c.Param("short_url")
	ip := c.ClientIP()
	userAgent := c.GetHeader("User-Agent")
	dto, err := statsToControllerDTO(code, ip, userAgent)
	if err != nil {
		c.JSON(http.StatusUnprocessableEntity, router.H{"error": err.Error()})
		return
	}

	longURL, err := h.usecase.GetOriginal(
		c.Request.Context(),
		dto.ShortCode,
		dto.IP,
		dto.UserAgent,
	)
	if err != nil {
		c.JSON(http.StatusNotFound, router.H{"error": "not found"})
		return
	}

	h.log.Info().Str("longURL", longURL).Msg("redirect")
	c.Redirect(http.StatusFound, longURL)
}

// GetAnalytics godoc
// @Summary      Get URL Analytics
// @Description  Get click statistics for a short URL
// @Tags         analytics
// @Produce      json
// @Param        short_url path string true "Short URL alias"
// @Success      200  {object}  statsControllerDTO
// @Failure      500  {object}  map[string]string
// @Router       /analytics/{short_url} [get]
func (h *handler) GetAnalytics(c *router.Context) {
	code := c.Param("short_url")

	var stats domain.Stats
	stats, err := h.usecase.GetStats(c.Request.Context(), code)
	if err != nil {
		h.log.Error().Err(err).Msg("failed to get count shorten url")
		c.JSON(http.StatusInternalServerError, router.H{"error": "db error"})
		return
	}

	c.JSON(http.StatusOK, statsToResponse(stats))
}

--- FILE: ./internal/controller/shortener_test.go ---
package controller_test

import (
	"bytes"
	"context"
	"errors"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/adexcell/shortener/internal/controller"
	"github.com/adexcell/shortener/internal/domain"
	"github.com/adexcell/shortener/pkg/logger"
	"github.com/adexcell/shortener/pkg/router"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

// --- Mocks ---

type MockUsecase struct {
	mock.Mock
}

func (m *MockUsecase) Shorten(ctx context.Context, shortCode, longURL string) (string, error) {
	args := m.Called(ctx, shortCode, longURL)
	return args.String(0), args.Error(1)
}

func (m *MockUsecase) GetOriginal(ctx context.Context, shortCode, ip, userAgent string) (string, error) {
	args := m.Called(ctx, shortCode, ip, userAgent)
	return args.String(0), args.Error(1)
}

func (m *MockUsecase) GetStats(ctx context.Context, shortCode string) (domain.Stats, error) {
	args := m.Called(ctx, shortCode)
	return args.Get(0).(domain.Stats), args.Error(1)
}

func (m *MockUsecase) Close() error {
	// TODO:
	return nil
}

// --- Setup ---

func setupRouter() *router.Router {
	// Use test mode to suppress debug logs
	return router.NewRouter(router.Config{GinMode: "test"})
}

// --- Tests ---

func TestHandler_PostShortURL(t *testing.T) {
	log := logger.NewLogger()

	t.Run("success", func(t *testing.T) {
		mockUC := new(MockUsecase)
		r := setupRouter()
		h := controller.NewShortenHandler(mockUC, log)
		h.Register(r)

		inputBody := `{"url": "https://example.com"}`
		expectedCode := "abcdef"

		// Expectation
		mockUC.On("Shorten", mock.Anything, "", "https://example.com").Return(expectedCode, nil)

		// Request
		w := httptest.NewRecorder()
		req, _ := http.NewRequest("POST", "/shorten", bytes.NewBufferString(inputBody))
		r.ServeHTTP(w, req)

		// Assertions
		assert.Equal(t, http.StatusOK, w.Code)
		assert.Contains(t, w.Body.String(), expectedCode)
		mockUC.AssertExpectations(t)
	})

	t.Run("invalid json", func(t *testing.T) {
		mockUC := new(MockUsecase)
		r := setupRouter()
		h := controller.NewShortenHandler(mockUC, log)
		h.Register(r)

		// Request (empty body)
		w := httptest.NewRecorder()
		req, _ := http.NewRequest("POST", "/shorten", bytes.NewBufferString(""))
		r.ServeHTTP(w, req)

		// Assertions
		assert.Equal(t, http.StatusBadRequest, w.Code)
		mockUC.AssertNotCalled(t, "Shorten")
	})

	t.Run("internal error", func(t *testing.T) {
		mockUC := new(MockUsecase)
		r := setupRouter()
		h := controller.NewShortenHandler(mockUC, log)
		h.Register(r)

		inputBody := `{"url": "https://example.com", "alias": "custom"}`

		// Expectation
		mockUC.On("Shorten", mock.Anything, "custom", "https://example.com").Return("", errors.New("db fail"))

		// Request
		w := httptest.NewRecorder()
		req, _ := http.NewRequest("POST", "/shorten", bytes.NewBufferString(inputBody))
		r.ServeHTTP(w, req)

		// Assertions
		assert.Equal(t, http.StatusInternalServerError, w.Code)
		mockUC.AssertExpectations(t)
	})
}

func TestHandler_ConversionURL(t *testing.T) {
	log := logger.NewLogger()

	t.Run("redirect success", func(t *testing.T) {
		mockUC := new(MockUsecase)
		r := setupRouter()
		h := controller.NewShortenHandler(mockUC, log)
		h.Register(r)

		shortCode := "abc1234"
		longURL := "https://google.com"

		// Expectation
		mockUC.On("GetOriginal", mock.Anything, shortCode, mock.Anything, mock.Anything).Return(longURL, nil)

		// Request
		w := httptest.NewRecorder()
		req, _ := http.NewRequest("GET", "/s/"+shortCode, nil)
		// Mock ClientIP for validation (Gin uses RemoteAddr or headers)
		req.RemoteAddr = "127.0.0.1:12345"

		r.ServeHTTP(w, req)

		// Assertions
		assert.Equal(t, http.StatusFound, w.Code) // 302
		assert.Equal(t, longURL, w.Header().Get("Location"))
		mockUC.AssertExpectations(t)
	})

	t.Run("not found", func(t *testing.T) {
		mockUC := new(MockUsecase)
		r := setupRouter()
		h := controller.NewShortenHandler(mockUC, log)
		h.Register(r)

		shortCode := "missing"

		// Expectation
		mockUC.On("GetOriginal", mock.Anything, shortCode, mock.Anything, mock.Anything).Return("", errors.New("not found"))

		// Request
		w := httptest.NewRecorder()
		req, _ := http.NewRequest("GET", "/s/"+shortCode, nil)
		req.RemoteAddr = "127.0.0.1:12345"

		r.ServeHTTP(w, req)

		// Assertions
		assert.Equal(t, http.StatusNotFound, w.Code)
		mockUC.AssertExpectations(t)
	})
}

--- FILE: ./internal/controller/shortener_dto.go ---
package controller

import (
	"time"

	"github.com/adexcell/shortener/internal/domain"
)

type shortenerControllerDTO struct {
	ID        string    `json:"id"`
	ShortCode string    `json:"short_code"`
	LongURL   string    `json:"long_url"`
	CreatedAt time.Time `json:"created_at"`
}

func shortenerToControllerDTO(shortCode, longURL string) (*shortenerControllerDTO, error) {
	s, err := domain.NewShortener(shortCode, longURL)
	if err != nil {
		return &shortenerControllerDTO{}, err
	}

	res := &shortenerControllerDTO{
		ID:        s.ID,
		ShortCode: s.ShortCode,
		LongURL:   s.LongURL,
	}
	return res, nil
}

func shortenerToDomain(dto shortenerControllerDTO) *domain.Shortener {
	return &domain.Shortener{
		ID:        dto.ID,
		ShortCode: dto.ShortCode,
		LongURL:   dto.LongURL,
		CreatedAt: dto.CreatedAt,
	}
}



--- FILE: ./pkg/logger/logger.go ---
// Package logger является оберткой над вспомогательным пакетом wbf/zlog.
package logger

import "github.com/wb-go/wbf/zlog"

type Log = zlog.Zerolog

func NewLogger() Log {
	zlog.InitConsole()
	return zlog.Logger
}

--- FILE: ./pkg/utils/uuid/uuid.go ---
// Package uuid является оберткой над вспомогательным пакетом wbf/helpers.
package uuid

import (
	"github.com/wb-go/wbf/helpers"
)

// New создает новый случайный UUID.
func New() string {
	return helpers.CreateUUID()
}

// Parse проверяет, является ли строка валидным UUID.
func Parse(s string) error {
	return helpers.ParseUUID(s)
}

--- FILE: ./pkg/redis/redis.go ---
// Package redis является оберткой над вспомогательным пакетом wbf/redis.
package redis

import (
	"time"

	"github.com/wb-go/wbf/redis"
)

type RDB = redis.Client

type Config struct {
	Addr     string        `mapstructure:"addr"`
	Password string        `mapstructure:"password"`
	DB       int           `mapstructure:"db"`
	TTL      time.Duration `mapstructure:"TTL"`
}

func NewRedis(cfg Config) *RDB {
	return redis.New(cfg.Addr, cfg.Password, cfg.DB)
}

--- FILE: ./pkg/postgres/postgres.go ---
// Package postgres является оберткой над вспомогательным пакетом wbf/dbpg.
package postgres

import (
	"fmt"
	"time"

	"github.com/wb-go/wbf/dbpg"
)

type DB = dbpg.DB

type Config struct {
	MasterDSN       string        `mapstructure:"master_dsn"`
	SlavesDSN       []string      `mapstructure:"slaves_dsn"`
	MaxOpenConns    int           `mapstructure:"max_open_conns"`
	MaxIdleConns    int           `mapstructure:"max_idle_conns"`
	ConnMaxLifetime time.Duration `mapstructure:"conn_max_life_time"`
}

func NewPostgres(cfg Config) (*DB, error) {
	dbOpts := &dbpg.Options{
		MaxOpenConns:    cfg.MaxOpenConns,
		MaxIdleConns:    cfg.MaxIdleConns,
		ConnMaxLifetime: cfg.ConnMaxLifetime,
	}

	db, err := dbpg.New(cfg.MasterDSN, cfg.SlavesDSN, dbOpts)
	if err != nil {
		return nil, fmt.Errorf("DB connection failed: %w", err)
	}
	if err := db.Master.Ping(); err != nil {
		return nil, fmt.Errorf("DB Ping failed - check your DSN and SSL mode: %w", err)
	}

	return db, nil
}

--- FILE: ./pkg/postgres/error.go ---
package postgres

import (
	"errors"

	"github.com/lib/pq"
)

func PostgresErr(err error) error {
	if pgErr, ok := err.(*pq.Error); ok && pgErr.Code == "23505" {
		return errors.New("this alias is already taken")
	}
	return err
}

--- FILE: ./pkg/router/http_v1.go ---
// Package router является оберткой над вспомогательным пакетом wbf/ginext.
package router

import (
	"github.com/wb-go/wbf/ginext"
)

type Router = ginext.Engine
type Context = ginext.Context
type H = ginext.H

type Handler interface {
	Register(router *Router)
}

type Config struct {
	GinMode string `mapstructure:"gin_mode"`
}

func NewRouter(cfg Config) *Router {
	return ginext.New(cfg.GinMode)
}

--- FILE: ./pkg/httpserver/httpserver.go ---
// Package httpserver пакет для настройки и конфигурирования сервера.
package httpserver

import (
	"net/http"
	"time"
)

type Config struct {
	Port string `mapstructure:"port"`
	ShutdownTimeout time.Duration `mapstructure:"shutdown_timeout"`
}

func New(cfg Config, router http.Handler) *http.Server {
	return &http.Server{
		Addr:    ":" + cfg.Port,
		Handler: router,
	}
}

--- FILE: ./static/main.css ---
/* static/main.css */
body {
    font-family: sans-serif;
    max-width: 600px;
    margin: 50px auto;
    padding: 20px;
    line-height: 1.6;
    background-color: #f9f9f9;
}

.section {
    background: white;
    border: 1px solid #ddd;
    padding: 20px;
    border-radius: 8px;
    margin-bottom: 20px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}

h2 {
    margin-top: 0;
    color: #333;
}

input {
    width: 100%;
    padding: 12px;
    margin: 10px 0;
    box-sizing: border-box;
    border: 1px solid #ccc;
    border-radius: 4px;
}

button {
    padding: 10px 20px;
    background: #007bff;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 16px;
    transition: background 0.2s;
}

button:hover {
    background: #0056b3;
}

#result, #statsResult {
    margin-top: 15px;
    font-weight: bold;
    word-break: break-all;
}

.error {
    color: #dc3545;
}

.success {
    color: #28a745;
}

pre {
    background: #f4f4f4;
    padding: 15px;
    font-size: 13px;
    border-radius: 4px;
    overflow-x: auto;
    border: 1px solid #eee;
}

--- FILE: ./static/main.js ---
document.addEventListener('DOMContentLoaded', () => {
    const shortenBtn = document.getElementById('shortenBtn');
    const statsBtn = document.getElementById('statsBtn');

    // --- ЛОГИКА СОКРАЩЕНИЯ ---
    shortenBtn.addEventListener('click', async () => {
        const longUrl = document.getElementById('longUrl').value;
        const alias = document.getElementById('alias').value;
        const resultDiv = document.getElementById('result');

        try {
        const response = await fetch('/shorten', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ url: longUrl, alias: alias })
        });

        const data = await response.json();
        if (response.ok) {

            resultDiv.innerHTML = `Код: ${data.short_url} <br> <a href="/s/${data.short_url}" target="_blank">Перейти</a>`;
        } else {
            resultDiv.innerHTML = `<span class="error">${data.error}</span>`;
        }
    } catch (e) {
        resultDiv.innerHTML = `<span class="error">Сервер недоступен</span>`;
    }
});

    // --- ЛОГИКА АНАЛИТИКИ ---
    statsBtn.addEventListener('click', async () => {
    let code = document.getElementById('statsCode').value.trim();
    
    if (code.includes('/s/')) {
        code = code.split('/s/').pop();
    }

    const statsResult = document.getElementById('statsResult');
    try {
        const response = await fetch(`/analytics/${code}`);
        if (!response.ok) throw new Error('Not found');
        
        const data = await response.json();
        statsResult.innerHTML = `
            <p>Всего кликов: ${data.total_clicks}</p>
            <pre>${JSON.stringify(data.by_browser, null, 2)}</pre>
        `;
    } catch (e) {
        statsResult.innerHTML = `<span class="error">Статистика не найдена</span>`;
    }
  }); 
});

--- FILE: ./static/index.html ---
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>URL Shortener</title>
    <!-- Подключаем CSS -->
    <link rel="stylesheet" href="/static/main.css">
</head>
<body>

    <div class="section">
        <h2>Сократить ссылку</h2>
        <input type="text" id="longUrl" placeholder="Введите длинную ссылку (http://...)">
        <input type="text" id="alias" placeholder="Кастомный алиас (необязательно)">
        <button id="shortenBtn">Сократить</button>
        <div id="result"></div>
    </div>

    <div class="section">
        <h2>Проверить аналитику</h2>
        <input type="text" id="statsCode" placeholder="Введите короткий код">
        <button id="statsBtn">Получить статистику</button>
        <div id="statsResult"></div>
    </div>

    <!-- Подключаем JS -->
    <script src="/static/main.js"></script>
</body>
</html>

--- FILE: ./config/config.go ---
package config

import (
	"github.com/adexcell/shortener/pkg/httpserver"
	"github.com/adexcell/shortener/pkg/postgres"
	"github.com/adexcell/shortener/pkg/redis"
	"github.com/adexcell/shortener/pkg/router"
	"github.com/wb-go/wbf/config"
)

type Config struct {
	App        App               `mapstructure:"app"`
	HTTPServer httpserver.Config `mapstructure:"httpserver"`
	Router     router.Config     `mapstructure:"router"`
	Postgres   postgres.Config   `mapstructure:"postgres"`
	Redis      redis.Config      `mapstructure:"redis"`
}

type App struct {
	AppName    string `mapstructure:"app_name"`
	AppVersion string `mapstructure:"app_version"`
}

func Load() (*Config, error) {
	cfg := config.New()

	cfg.EnableEnv("")

	_ = cfg.LoadEnvFiles(".env")

	if err := cfg.LoadConfigFiles("config/config.yaml"); err != nil {
		return nil, err
	}

	var res Config
	if err := cfg.Unmarshal(&res); err != nil {
		return nil, err
	}

	return &res, nil
}

--- FILE: ./config/config.yaml ---
app:
  app_name: "shortener"
  app_version: "0.0.1"

httpserver:
  port: "8080"
  shutdown_timeout: 5s

router:
  gin_mode: debug

postgres:
  master_dsn: "postgres://postgres:pass@localhost:5432/shortener?sslmode=disable"
  slaves_dsn: []
  max_open_conns: 10
  max_idle_conns: 5
  conn_max_life_time: 20m

redis:
  addr: "localhost:6379"
  password: ""
  db: 0
  TTL: 24h

--- FILE: ./migrations/000001_init.up.sql ---
CREATE TABLE IF NOT EXISTS urls (
    id UUID PRIMARY KEY,
    short_code VARCHAR(10) UNIQUE NOT NULL,
    long_url TEXT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS analytics (
    id UUID PRIMARY KEY,
    short_code VARCHAR(10) NOT NULL,
    ip VARCHAR(45),
    user_agent TEXT,
    clicked_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);

